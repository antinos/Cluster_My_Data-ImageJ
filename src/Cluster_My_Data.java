import ij.*;
import ij.gui.Plot;
import ij.measure.ResultsTable;
import ij.plugin.PlugIn;
import ij.plugin.filter.Analyzer;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;

import com.clust4j.algo.AffinityPropagation;
import com.clust4j.algo.AffinityPropagationParameters;
import com.clust4j.algo.DBSCAN;
import com.clust4j.algo.DBSCANParameters;
import com.clust4j.algo.HDBSCAN;
import com.clust4j.algo.HDBSCANParameters;
import com.clust4j.algo.KMeans;
//import com.clust4j.data.DataSet;
//import com.clust4j.data.ExampleDataSets;
import com.clust4j.algo.KMeansParameters;
import com.clust4j.algo.KMedoids;
import com.clust4j.algo.KMedoidsParameters;
import com.clust4j.metrics.pairwise.Distance;
import com.clust4j.metrics.pairwise.GeometricallySeparable;

/**version 0.0.2*/

/**
 * Clustering algorithm library 'clust4j' created by Taylor G Smith (https://github.com/tgsmith61591/clust4j) and distributed under the Apache License 2.0.
 * Processes the 'Plot Values' table generated by a standard ImageJ plot.
 */
public class Cluster_My_Data implements PlugIn {
	//Top level initialisation
	double[][] imageMatrix;
	String[] Filelist;
	String[] labelsArray;
	
    // Options to use during the run. Defaults for some but otherwise populated when parseOptions() is called.
    //private String inputFolderPath;
    private String inputIndexPath; //show the plugin where sample labels are located.. used to colour the final output.
    private String metric; //distance metric/measure, used to compute the distance, or dissimilarity, between pairs of observations.
    private GeometricallySeparable metric_dist;
    //
    private boolean hdbscan;
    private String minClusSize;	//HDBSCAN parameter
    private String minPoints; //HDBSCAN + DBSCAN parameter
    private int minCS; //HDBSCAN minimum Cluster Size (optional) variable. 
    private int minP; //Minimum points. The larger the value, the more points will be declared as noise, and clusters will be restricted to progressively more dense areas. Defaults to minCS.
    //
    private String kmeans;
    private String kmedoids;
    private int K; //k-means k
    //
    private boolean dbscan;
    private String epsilon;
    private double eps; //How close points should be to each other to be considered a part of a cluster. If the distance between two points is less than or equal to eps, these points are considered neighbours.
    //
    private boolean affprop; // Affinity Propagation. GENERAL NOTE: this algorithm is quite slow for large datasets and has a tendency to find a high number of clusters with the default settings.
    private String dampFactor;
    private String iterBreak;
    private String maxIter;
    private double dampFac; //0.5-1
    private int itBreak; //The number of stagnant iterations after which the algorithm will declare convergence. Must be over 0.
    private int maxIt; //The max iterations. Must be over 0.
    
		//damping factor (between 0.5 and 1)	default=0.5				setDampingFactor
		//iterBreak (over 0)					default=15				setIterBreak			Number of stagnant iters after which to break (The number of stagnant iterations after which the algorithm will declare convergence)
		//maxIter (over 0)						default=200				setMaxIter				The max iterations
		//metric														setMetric				Looks like it should work
    //
    private boolean outputCSV = false; //create a CSV copy of the tSNE 2D output on the users desktop.
    boolean resultWin = false; //flag to set if a results window is open at the start of the run.
    
    // Variables and main() method for testing in IDEs.
    private static String debugOptions = null;
    //private static double[][] debugArray = null;
    public static void main(String[] args) {
        // To debug, set a CSV file to open, we'll use that in the ResultsTable for the run.
        new Cluster_My_Data().run("");
    }
    

    public void run(String arg) {
        // Fill in the options we'll use during this run.
        parseOptions();
        
        String[] titles = WindowManager.getNonImageTitles();
        if (!ArrayUtils.contains(titles, "Plot Values")) {
        	IJ.showMessage("Clustering pulls data from a table entitled 'Plot Values'.\nTry renaming a 2D(X,Y) table with this title and try again.");
        	return;
        }
        
        //Get the data from the Plot Values window
	        /*
	        IJ.runMacro("selectWindow(\"Plot Values\")");
	        Window plotWin = WindowManager.getWindow("Plot Values");
	        //ResultsTable rt = plotWin.getTextPanel().getResultsTable(); //does not work
	        String test = rt.getRowAsString(0);
	        IJ.log(""+test);
	        */
        //There must be a way to get data from a non-results table using the IJ api.... maybe via a TextPanel, but I couldn't immediately see how. I'll let the macro rename our 'Plot Values' table to 'Results' so that I can use the Analyzer class instead.
        if (IJ.isResultsWindow()) {
        	 IJ.runMacro("Table.rename(\"Results\", \"Results_1\");"); //if a results table exists, change its name so that we don't destroy it.
        	 resultWin = true;
        }
        IJ.runMacro("selectWindow(\"Plot Values\")");
        IJ.runMacro("Table.rename(\"Plot Values\", \"Results\");");
        ResultsTable rt = Analyzer.getResultsTable();
        rt.showRowNumbers(false);
        
        String[] headings = new String[ rt.getHeadings().length];
        headings = rt.getHeadings();
	        /* Optional warning that pre-clustered data will be concatenated.
	        if (headings.length > 2) {
	        	int choice = JOptionPane.showConfirmDialog(null, "There are multiple datasets already. Do you want to join them before clustering?", "",JOptionPane.YES_NO_CANCEL_OPTION);
	            if (choice == JOptionPane.CANCEL_OPTION || choice == JOptionPane.NO_OPTION) {
	            	IJ.runMacro("Table.rename(\"Results\", \"Plot Values\");");
	            	return;
	            	}
	            else if (choice == JOptionPane.OK_OPTION) {
	            	//do nothing... continue.
	            }
	        }
	        */
        double[] xArray = new double[0];
        double[] yArray = new double[0];
        for (int i=0; i<headings.length; i+=2) {
        	for (int n=0; n<rt.size(); n++) {
        		if (!Double.isNaN(rt.getValueAsDouble(i, n))) {
        			xArray = ArrayUtils.add(xArray, rt.getValueAsDouble(i, n)); //using Apache commons utility for convenience
        			yArray = ArrayUtils.add(yArray, rt.getValueAsDouble(i+1, n));
        		} else {
        			break;
        		}
        	}
            //IJ.log(""+String.valueOf(xArray.length));
        }
        
        IJ.runMacro("Table.rename(\"Results\", \"Plot Values\");");
        if (resultWin) {
        	IJ.runMacro("Table.rename(\"Results_1\", \"Results\");");
        }
        
        double[][] Y = new double[xArray.length][2]; //possibly needs to be [xArray.length][2]
        for (int k=0; k<xArray.length; k++) {
        	Y[k][0] = xArray[k];
        	Y[k][1] = yArray[k];
        }	
        
        //Get and use labels if a .csv file is specified.
        if (!inputIndexPath.isEmpty()) {
        	labelsArray = null;
        	try {
				labelsArray = getLabels(inputIndexPath);
			} catch (IOException e) {
				IJ.handleException(e);
			}
        	if (labelsArray == null) {
        		IJ.log("The specified labels file is empty or corrupt.");
        	}
        	if (labelsArray.length != Y.length) {
        		IJ.log("The number of labels in the labels file does not match the number of datapoints, so it has not been used to assign groupings.");
        		IJ.log("Y.length = "+String.valueOf(Y.length)+"; Label number = "+String.valueOf(labelsArray.length));
        		IJ.log(Arrays.toString(labelsArray));
        		labelsArray = null;
        	}
        }
        
        //If dbscan clustering is specified, use it to populate the labelsArray. Pass epsilon and minimum points parameters if specified.
        if (dbscan) {
        	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
        	if (minPoints != null && !("").equals(minPoints) && !minPoints.matches(".*[A-Za-z].*") && Integer.valueOf(minPoints) > 0) {
        		minP = (int) Integer.valueOf(minPoints);
        			//IJ.log("MinP has been set to "+minPoints);
        	} else {
        		minP = DBSCAN.DEF_MIN_PTS;
        		minPoints = String.valueOf(DBSCAN.DEF_MIN_PTS); //updating the minPoints string only to add the plot title
        			//IJ.log("MinP has been set to DEF_MINPTS, which = "+String.valueOf(DBSCAN.DEF_MIN_PTS));
        	}
        	if (epsilon != null && !("").equals(epsilon) && !epsilon.matches(".*[A-Za-z].*") && Double.valueOf(epsilon) > 0) {
        		eps = (double) Double.valueOf(epsilon);
        		DBSCAN db = new DBSCANParameters(eps).setMinPts(minP).fitNewModel(Ymatrix);
            	final int[] dbresult = db.getLabels();
            	labelsArray = new String[dbresult.length];
            	for (int i=0; i<dbresult.length; i++) {
            		labelsArray[i] = String.valueOf(dbresult[i]);
            	}
        	} else {
        		DBSCAN db = new DBSCANParameters().setMinPts(minP).fitNewModel(Ymatrix);
            	final int[] dbresult = db.getLabels();
            	labelsArray = new String[dbresult.length];
            	for (int i=0; i<dbresult.length; i++) {
            		labelsArray[i] = String.valueOf(dbresult[i]);
            	}
        	}
        }
        
        //If hdbscan clustering is specified, use it to populate the labelsArray <-- Sometimes fails. NullPointer exception isn't that illuminating as to why. Pass a minimum cluster size and minimum points parameters if specified.
        if (hdbscan) {
        	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
        	if (minPoints != null && !("").equals(minPoints) && !minPoints.matches(".*[A-Za-z].*") && Integer.valueOf(minPoints) > 0) {
        		minP = (int) Integer.valueOf(minPoints);
        			//IJ.log("MinP has been set to "+minPoints);
        	} else {
        		minP = HDBSCAN.DEF_MIN_PTS;
        			//IJ.log("MinP has been set to DEF_MINPTS, which = "+String.valueOf(HDBSCAN.DEF_MIN_PTS));
        	}
        	if (minClusSize != null && !("").equals(minClusSize) && !minClusSize.matches(".*[A-Za-z].*") && Integer.valueOf(minClusSize) > 0) {
        		minCS = (int) Integer.valueOf(minClusSize);
        			//IJ.log("MinCS has been set to "+minClusSize);
        			//IJ.log("minP = "+String.valueOf(minP));
        		HDBSCAN hdb = new HDBSCANParameters(minP).setMinClustSize(minCS).fitNewModel(Ymatrix); //min_cluster_size = smallest grouping you wish to have as a cluster
            	final int[] dbresult = hdb.getLabels();
            	labelsArray = new String[dbresult.length];
            	for (int i=0; i<dbresult.length; i++) {
            		labelsArray[i] = String.valueOf(dbresult[i]);
            	}
        	} else {
        		minClusSize = String.valueOf(HDBSCAN.DEF_MIN_CLUST_SIZE); //we don't need minClusSize at this point, except to write what the default value is to the plot title.
        			//IJ.log("No other conditions met. Default HDBSCAN was run.");
        			//IJ.log("minP = "+String.valueOf(minP));
        		HDBSCAN hdb = new HDBSCANParameters(minP).fitNewModel(Ymatrix);
            	final int[] dbresult = hdb.getLabels();
            	labelsArray = new String[dbresult.length];
            	for (int i=0; i<dbresult.length; i++) {
            		labelsArray[i] = String.valueOf(dbresult[i]);
            	}
        	}
        }
        
        //If affinity-propagation clustering is specified, use it to populate the labelsArray
        if (affprop) {
        	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
        	if (dampFactor != null && !("").equals(dampFactor) && !dampFactor.matches(".*[A-Za-z].*") && Double.valueOf(dampFactor) >= 0.5 && Double.valueOf(dampFactor) <= 1) {
        		dampFac = (double) Double.valueOf(dampFactor);
        			//IJ.log("dampFac has been set to "+dampFac);
        	} else {
        		dampFac = AffinityPropagation.DEF_DAMPING; //default = 0.5
        			//IJ.log("dampFac has been set to DEF_DAMPING, which = "+String.valueOf(AffinityPropagation.DEF_DAMPING));
        	}
        	if (iterBreak != null && !("").equals(iterBreak) && !iterBreak.matches(".*[A-Za-z].*") && Integer.valueOf(iterBreak) > 0) {
        		itBreak = (int) Integer.valueOf(iterBreak);
        			//IJ.log("itBreak has been set to "+itBreak);
        	} else {
        		itBreak = AffinityPropagation.DEF_ITER_BREAK; //default = 15
        			//IJ.log("itBreak has been set to DEF_ITER_BREAK, which = "+String.valueOf(AffinityPropagation.DEF_ITER_BREAK));
        	}
        	if (maxIter != null && !("").equals(maxIter) && !maxIter.matches(".*[A-Za-z].*") && Integer.valueOf(maxIter) > 0) {
        		maxIt = (int) Integer.valueOf(maxIter);
        			//IJ.log("maxIt has been set to "+maxIt);
        	} else {
        		maxIt = AffinityPropagation.DEF_MAX_ITER; //default = 200
        			//IJ.log("maxIt has been set to DEF_MAX_ITER, which = "+String.valueOf(AffinityPropagation.DEF_MAX_ITER));
        	}
        	AffinityPropagation ap = new AffinityPropagationParameters().setDampingFactor(dampFac).setIterBreak(itBreak).setMaxIter(maxIt).setMetric(metric_dist).fitNewModel(Ymatrix);
        	final int[] apresult = ap.getLabels();
        	labelsArray = new String[apresult.length];	
        	for (int i=0; i<apresult.length; i++) {
        		labelsArray[i] = String.valueOf(apresult[i]);
        	}
        }
        
      //If k-means clustering is specified, use it to populate the labelsArray
        if (kmeans != "") {
        	K = (int) Integer.valueOf(kmeans);
        	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
        	KMeans km = new KMeansParameters(K).fitNewModel(Ymatrix);
        	final int[] kmresult = km.getLabels();
        	labelsArray = new String[kmresult.length];
        	for (int i=0; i<kmresult.length; i++) {
        		labelsArray[i] = String.valueOf(kmresult[i]);
        	}
        }
        
        //If k-medoids clustering is specified, use it to populate the labelsArray //TO DO.. check if an optional parameters can be passed for this
        if (kmedoids != "") {
        	K = (int) Integer.valueOf(kmedoids);
        	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
        	KMedoids kmed = new KMedoidsParameters(K).fitNewModel(Ymatrix);
        	final int[] kmedresult = kmed.getLabels();
        	labelsArray = new String[kmedresult.length];
        	for (int i=0; i<kmedresult.length; i++) {
        		labelsArray[i] = String.valueOf(kmedresult[i]);
        	}
        }
        
    	//If the outputCSV toggle is set, output the tSNE result to the users desktop
        if (outputCSV) {
        	try {
        		toCSV(Y, Filelist);
        	} catch (IOException e) {
        		IJ.handleException(e);
        	}
        }
        
       /* New double[] for X and Y. Not needed as we already have our original 1D arrays.
        double[] Xarray = new double[Y.length];
        double[] Yarray = new double[Y.length];
        for (int m = 0; m < Y[0].length; m++) { //columns
        	for (int n = 0; n < Y.length; n++) { //rows
        		if (m==0) {
        			Xarray[n] = Y[n][m];
        		} else {
        			Yarray[n] = Y[n][m];
        		}
        	}
        }
        */
        String plotTitle = new String("Plot (uncoloured)");
        if (kmeans != "" && labelsArray.length == Y.length) {
        	plotTitle = "Plot coloured by k-means (k = "+kmeans+")";
        } else if (kmedoids != "" && labelsArray.length == Y.length) {
        	plotTitle = "Plot coloured by K-medoids (k = "+kmedoids+")";
        } else if (hdbscan && labelsArray.length == Y.length) {
        	plotTitle = "Plot coloured by HDBSCAN (min cluster size = "+minClusSize+", min points = "+minPoints+")";
        } else if (epsilon != "" && labelsArray.length == Y.length) {
        	plotTitle = "Plot coloured by DBSCAN (epsilon = "+String.valueOf(eps)+", min points = "+minPoints+")";
        } else if (affprop && labelsArray.length == Y.length) {
        	plotTitle = "Plot coloured by affinity-propagation (damping factor = "+String.valueOf(dampFac)+", metric = "+metric_dist.getName()+")";
        } else {
        	//do nothing to the title
        }
    	Plot scatter = new Plot(plotTitle, "X", "Y");
    	if (labelsArray == null) {
    		scatter.setLineWidth(5);
    		//scatter.addPoints(Xarray, Yarray, 6);
    		scatter.addPoints(xArray, yArray, 6);
    		scatter.show();
    	} else {
    		//some method to count unique entries (groups) in the labels array here. I expect processing overhead time-loss associated with this 'else' code.
    		ArrayList<String> uniqueArrayList = new ArrayList<>();
    	    for(int i=0; i<labelsArray.length; i++){
    	        if(!uniqueArrayList.contains(labelsArray[i])){
    	            uniqueArrayList.add(labelsArray[i]);
    	        }
    	    }
    		int groupN = uniqueArrayList.size();
    		String[] uniqueArray = new String[groupN];
    		uniqueArrayList.toArray(uniqueArray);
    		
    		for (int y = 0; y < groupN; y++) {
    			int counter = 0;
    			for (int z = 0; z < labelsArray.length; z++) {
    				if (labelsArray[z].equals(uniqueArray[y])) {
    					counter++;
    				}
    			}
    				//IJ.log(uniqueArray[y]+" is present "+String.valueOf(counter)+" time(s) in the labelsArray.");
    			double[] XXarray = new double[counter];
    			double[] YYarray = new double[counter];
    			counter = 0;
    			for (int z = 0; z < labelsArray.length; z++) {
    				if (labelsArray[z].equals(uniqueArray[y])) {
    					XXarray[counter] = xArray[z]; //was Xarray
    					YYarray[counter] = yArray[z]; //was Yarray
    					counter++;
    				}
    			}
        		//Randomly generate an rgb colour and add the datapoint of that colour to the plot.
    			Random rand = new Random();
    			int r = rand.nextInt(230);
    			int g = rand.nextInt(230);
    			int b = rand.nextInt(230);
    			Color ranCol = new Color(r,g,b);
 
    			scatter.setColor(ranCol);
    			scatter.setLineWidth(5);
    			scatter.addPoints(XXarray, YYarray, 6);
    			//scatter.addLegend(uniqueArray[y]);
    		}
    		StringBuilder sb = new StringBuilder();
    		for (int y = 0; y < groupN; y++) {
    			if (y != groupN-1) {
    				sb.append(uniqueArray[y]);
    				sb.append(System.getProperty("line.separator"));
    			} else {
    				sb.append(uniqueArray[y]);
    			}
    		}
    		String legendLabels = sb.toString();
    		scatter.addLegend(legendLabels);
    			//scatter.addLegend((uniqueArray.toString())); //gave odd results, depsite simplicity
    		scatter.show();
    		scatter.setLimitsToFit(true);
    			//IJ.log("File list: "+Arrays.toString(Filelist));
    	}
    	
    }
    
    
    /*
     * https://stackoverflow.com/questions/34958829/how-to-save-a-2d-array-into-a-text-file-with-bufferedwriter
     */
    public static void toCSV(double array[][], String Filelist[]) throws IOException {
  	  StringBuilder builder = new StringBuilder();
  	  for(int i = 0; i < array.length; i++)//for each row
  	  {
  	     for(int j = 0; j < array[0].length; j++)//for each column
  	     {
  	    	 if (j == 0) {
  	    		 builder.append(Filelist[i]);
  	    		 builder.append(",");
  	    	 }
  	    	 builder.append(array[i][j]+"");//append to the output string
  	    	 if(j < array.length - 1)//if this is not the last row element
  	    		 builder.append(",");//then add comma (if you don't like commas you can use spaces)
  	     }
  	     builder.append("\n");//append new line at the end of the row
  	  }
  	  String desktopPath = System.getProperty("user.home") + File.separator + "Desktop" + File.separator + "tSNE_result.csv";
  	  BufferedWriter writer = new BufferedWriter(new FileWriter(""+desktopPath));
  	  writer.write(builder.toString());//save the string representation of the board
  	  writer.close();
  	  }
    
    public String[] getLabels( String inputIndexPath) throws IOException {
    	BufferedReader br = null;
    	List<String> labelList = new ArrayList<String>();
    	
    	if (inputIndexPath.endsWith(".csv")) {
    		try {
    			String line = "";
    			br = new BufferedReader(new FileReader(inputIndexPath));
    			int lineCounter = 0;
    			while ((line = br.readLine()) != null) {
    				if (lineCounter == 0) {
    					lineCounter++;
    					continue;
    				} else {
    					lineCounter++;
    					labelList.add(line.replaceAll(",", ""));
    				}
    				
    			}
    			} catch (FileNotFoundException e) {
    			IJ.handleException(e);
    			} catch (IOException e) {
    			IJ.handleException(e);} finally {
    				if (br != null) {
    					try {
    						br.close(); 
    						} catch (IOException e) {
    							IJ.handleException(e);
    						}
    				}
    			}
    	} else {
    		IJ.log("The user has specified a labels file but it is not a .csv.");
    	}
    	String[] labels = new String[labelList.size()];
    	//IJ.log("labelList size is: "+String.valueOf(labelList.size()));
    	labels = labelList.toArray(labels);
    	//IJ.log("getLabels produces this: "+Arrays.toString(labels));
    	//IJ.log("getLabels result contains "+String.valueOf((labels.length)+" elements"));
    	return labels;
    }
    
    /**
     * Parses the options string used to run the plugin and extracts options for it. Uses defaults for any which aren't
     * specified.
     */
    private void parseOptions() {
        // Get the options string we were started using.
        String optionsStr = debugOptions == null ? Macro.getOptions() : debugOptions;
        if (optionsStr == null) optionsStr = "";

        // Input folder path to process.
        //inputFolderPath = Macro.getValue(optionsStr, "input_path", "");
        
        // Path to sample labels.
        inputIndexPath = Macro.getValue(optionsStr, "label_path", "");
        
        // Distance metric used to compute dissimilarity between pars of observations (an option for: affinity propagation and possibly most other algorithms) 
        metric = Macro.getValue(optionsStr, "metric", "euclidean");
    	if (metric != "euclidean") {
    		if (metric == "manhattan") {
    			metric_dist = Distance.MANHATTAN;
    		}
    		else if (metric == "chebyshev") {
    			metric_dist = Distance.CHEBYSHEV;
    		}
    		/*
    		else if (metric == "minkowski") {
    			//metric_dist = Distance.MINKOWSKI(p); //need to look into the passed double value
    		}
    		*/
    		else if (metric == "canberra") {
    			metric_dist = Distance.CANBERRA;
    		}
    		else if (metric == "braycurtis") {
    			metric_dist = Distance.BRAY_CURTIS;
    		}
    		/*
    		else if (metric == "cosine") {
    			//metric_dist = Distance.
    		}
    		else if (metric == "correlation") {
    			//metric_dist = Distance.
    		}
    		else if (metric == "haversine") {
    			//metric_dist = Distance.
    		}
    		*/
    		else if (metric == "hamming") {
    			metric_dist = Distance.HAMMING;
    		}
    		/*
    		else if (metric == "jaccard") {
    			//metric_dist = Distance.
    		}
    		*/
    		else if (metric == "dice") {
    			metric_dist = Distance.DICE;
    		}
    		else if (metric == "russelrao") {
    			metric_dist = Distance.RUSSELL_RAO;
    		}
    		else if (metric == "kulsinski") {
    			metric_dist = Distance.KULSINSKI;
    		}
    		else if (metric == "rogerstanimoto") {
    			metric_dist = Distance.ROGERS_TANIMOTO;
    		}
    		/*
    		else if (metric == "sokalmichener") {
    			//metric_dist = Distance.
    		}
    		*/
    		else if (metric == "sokalsneath") {
    			metric_dist = Distance.SOKAL_SNEATH;
    		}
    		else if (metric == "yule") {
    			metric_dist = Distance.YULE;
    		}
		} else {
			metric_dist = Distance.EUCLIDEAN;
		}
        
        // Figure out if we want to do hdbscan clustering on the 2d data.
        hdbscan = optionsStr.contains("hdbscan");
        
	        // Retrieve a hdbscan Minimum Cluster Size.
	        minClusSize = Macro.getValue(optionsStr, "min_clus_size", "");
	        
	        // Retrieve a (h)dbscan Minimum Points value.
	        minPoints = Macro.getValue(optionsStr, "min_points", "");
        
        // Figure out if we want to do k-means clustering and retrieve the value of k.
        kmeans = Macro.getValue(optionsStr, "k_means", "");
        
        // Figure out if we want to do k-means clustering and retrieve the value of k.
        kmedoids = Macro.getValue(optionsStr, "k_medoids", "");
        
        // Figure out if we want to do dbscan clustering on the 2d data.
        dbscan = optionsStr.contains("dbscan");
        
	        // Retrieve a dbscan epsilon value.
	        epsilon = Macro.getValue(optionsStr, "epsilon", "");
        
        // Figure out if we want to do dbscan clustering on the 2d data.
        affprop = optionsStr.contains("affinity_prop");

	        // Affinity propagation damping factor (range: 0.5-1)
	        dampFactor = Macro.getValue(optionsStr, "damping_factor", "");
	        
	        // The number of stagnant iterations after which the algorithm will declare convergence [affinity propagation]
	        iterBreak = Macro.getValue(optionsStr, "iterations_break", "");
	        
	        // The max iterations [affinity propagation]
	        maxIter = Macro.getValue(optionsStr, "max_iterations", "");
        
        // See if a CSV output is requested.
        outputCSV = optionsStr.contains("output_csv");
        
    }
    
    //Example method implementation of dbscan.
    /*
    private String[] dbscanMethod(double[][] Y , double epsilon) {
    	final Array2DRowRealMatrix Ymatrix = new Array2DRowRealMatrix(Y);
    	DBSCAN db = new DBSCANParameters(epsilon).fitNewModel(Ymatrix); //epsilon of 0.3 works well for Olivetti faces
    	final int[] dbresult = db.getLabels();
    	labelsArray = new String[dbresult.length];
    	for (int i=0; i<dbresult.length; i++) {
    	labelsArray[i] = String.valueOf(dbresult[i]);
    	}
    	return labelsArray;
    }
    */
    
}